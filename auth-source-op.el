;;; auth-source-op.el --- Auth-source backend for 1Password -*- lexical-binding: t; -*-

;; Copyright (C) 2025 Chris Barrett

;; Author: Chris Barrett <chris@walrus.cool>
;; Package-Requires: ((emacs "28.1"))
;; Homepage: https://github.com/chrisbarrett/emacs-auth-source-op
;; Version: 0.1.0

;; This code was generated by Claude (Anthropic) with human direction and
;; review. It is dual-licensed under The Unlicense and GPL-3.0-or-later.
;; See LICENSE for details.

;;; Commentary:

;; Emacs auth-source backend for 1Password via the `op` CLI.
;;
;; This package enables `auth-source-search' to retrieve credentials from
;; 1Password, allowing Gnus, Forge, TRAMP, etc. to authenticate transparently.
;;
;; Requirements:
;; - `op' CLI in PATH
;; - 1Password desktop app (for biometric unlock)
;;
;; Usage:
;;   (require 'auth-source-op)
;;   (auth-source-op-enable)

;;; Code:

(require 'cl-lib)
(require 'json)
(require 'seq)
(require 'url-parse)
(require 'auth-source)
(require 'eieio)

(defgroup auth-source-op nil
  "Auth-source backend for 1Password."
  :group 'auth-source
  :prefix "auth-source-op-")

(defcustom auth-source-op-retry-count 3
  "Maximum number of retries for biometric authentication failures."
  :type 'integer
  :group 'auth-source-op)

(defcustom auth-source-op-vaults nil
  "List of 1Password vaults to search for credentials.
Each element can be a vault name (e.g., \"Personal\") or vault ID.
When nil or empty, all vaults are searched (default behavior)."
  :type '(repeat string)
  :group 'auth-source-op)

;;; Error Pattern Detection

(defconst auth-source-op--biometric-patterns
  '("authorization denied"
    "biometric"
    "authentication required"
    "touch id")
  "Patterns in stderr that indicate biometric authentication failure.")

(defconst auth-source-op--cancel-patterns
  '("user cancelled"
    "user canceled"
    "aborted"
    "operation was cancelled"
    "operation was canceled")
  "Patterns in stderr that indicate user cancelled authentication.")

(defun auth-source-op--biometric-failure-p (stderr)
  "Return non-nil if STDERR indicates a biometric authentication failure."
  (let ((stderr-lower (downcase stderr)))
    (cl-some (lambda (pattern)
               (string-match-p (regexp-quote pattern) stderr-lower))
             auth-source-op--biometric-patterns)))

(defun auth-source-op--user-cancelled-p (stderr)
  "Return non-nil if STDERR indicates user cancelled authentication."
  (let ((stderr-lower (downcase stderr)))
    (cl-some (lambda (pattern)
               (string-match-p (regexp-quote pattern) stderr-lower))
             auth-source-op--cancel-patterns)))

;;; Disambiguation UI

(defun auth-source-op--format-item-for-display (item)
  "Format ITEM for display in `completing-read'.
Returns a string showing the item title and first URL hostname."
  (let* ((title (or (alist-get 'title item) "Untitled"))
         (urls (auth-source-op--item-urls item))
         (host (auth-source-op--extract-hostname (car urls))))
    (if host
        (format "%s (%s)" title host)
      title)))

(defun auth-source-op--disambiguate (items)
  "Prompt user to select one item from ITEMS.
Returns the selected item, or nil if cancelled.
If ITEMS contains only one element, returns it without prompting."
  (cond
   ((null items) nil)
   ((null (cdr items)) (car items))  ; Single item, no prompt needed
   (t
    (let* ((candidates (mapcar (lambda (item)
                                 (cons (auth-source-op--format-item-for-display item) item))
                               items))
           (choice (completing-read "Select 1Password item: "
                                    (mapcar #'car candidates)
                                    nil t)))
      (when choice
        (cdr (assoc choice candidates)))))))

;;; Field Mapping

(defconst auth-source-op--username-field-names
  '("username" "user" "email" "login" "account")
  "Field names to check when looking for a username.")

(defconst auth-source-op--secret-field-names
  '("password" "secret" "credential" "token" "api_key" "apikey" "key")
  "Field names to check when looking for a secret.")

(defun auth-source-op--fetch-item (item-id)
  "Fetch the full item details from 1Password for ITEM-ID.
Returns the item as an alist, or nil on failure."
  (auth-source-op--call-op "item" "get" item-id "--format=json"))

(defun auth-source-op--find-field-value (item field-names &optional purpose)
  "Find a field value in ITEM matching one of FIELD-NAMES.
FIELD-NAMES is a list of field names to search for (case-insensitive).
PURPOSE is an optional symbol; if \\='password, also checks the field type.
Returns the field value as a string, or nil if not found."
  (let ((fields (alist-get 'fields item)))
    (when fields
      (let ((fields-list (if (vectorp fields) (append fields nil) fields)))
        (cl-some
         (lambda (field)
           (let ((label (downcase (or (alist-get 'label field) "")))
                 (id (downcase (or (alist-get 'id field) "")))
                 (field-type (alist-get 'type field))
                 (value (alist-get 'value field)))
             (when (and value
                        (or
                         ;; Match by label or id
                         (cl-some (lambda (name)
                                    (or (string= (downcase name) label)
                                        (string= (downcase name) id)))
                                  field-names)
                         ;; For password purpose, also match by field type
                         (and (eq purpose 'password)
                              (equal field-type "CONCEALED"))))
               value)))
         fields-list)))))

(defun auth-source-op--extract-username (item)
  "Extract the username from a 1Password ITEM.
Returns the username as a string, or nil if not found."
  (auth-source-op--find-field-value item auth-source-op--username-field-names))

(defun auth-source-op--make-secret-closure (item-id)
  "Create a zero-arg closure that fetches the secret for ITEM-ID.
The closure fetches the secret lazily when called, implementing
deferred retrieval as required by auth-source."
  (lambda ()
    (let ((item (auth-source-op--fetch-item item-id)))
      (when item
        (auth-source-op--find-field-value item auth-source-op--secret-field-names 'password)))))

(defun auth-source-op--map-item-to-auth-source (item)
  "Map a 1Password ITEM summary to an auth-source result.
Returns a plist with :host, :port, :user, and :secret keys.
The :secret value is a zero-arg closure for deferred retrieval.
Returns nil if the item cannot be mapped."
  (let ((item-id (alist-get 'id item))
        (title (alist-get 'title item))
        (urls (auth-source-op--item-urls item)))
    (when item-id
      (let ((host (or (auth-source-op--extract-hostname (car urls))
                      title)))
        (list :host host
              :port nil  ; 1Password items don't have port metadata
              :user nil  ; Will be populated when full item is fetched
              :secret (auth-source-op--make-secret-closure item-id))))))

(defun auth-source-op--fetch-and-map-item (item)
  "Fetch full details for ITEM and map to auth-source result.
Returns a plist with :host, :port, :user, and :secret keys.
The :secret value is a zero-arg closure for deferred retrieval.
Returns nil if the item cannot be fetched or mapped."
  (let* ((item-id (alist-get 'id item))
         (title (alist-get 'title item))
         (urls (auth-source-op--item-urls item))
         (full-item (when item-id (auth-source-op--fetch-item item-id))))
    (when full-item
      (let ((host (or (auth-source-op--extract-hostname (car urls))
                      title))
            (user (auth-source-op--extract-username full-item)))
        (list :host host
              :port nil  ; 1Password items don't have port metadata
              :user user
              :secret (auth-source-op--make-secret-closure item-id))))))

;;; Item Search

(defun auth-source-op--extract-hostname (url)
  "Extract hostname from URL.
Returns nil if URL is invalid or has no host.
Handles URLs without a protocol by prepending https://."
  (when (and url (stringp url))
    (condition-case nil
        (let* ((normalized-url (if (string-match-p "\\`[a-zA-Z][a-zA-Z0-9+.-]*://" url)
                                   url
                                 (concat "https://" url)))
               (parsed (url-generic-parse-url normalized-url)))
          (let ((host (url-host parsed)))
            (when (and host (not (string-empty-p host)))
              (downcase host))))
      (error nil))))

(defun auth-source-op--item-urls (item)
  "Return list of URLs from 1Password ITEM.
Extracts URLs from the `urls' field of an item summary."
  (let ((urls (alist-get 'urls item)))
    (when urls
      (mapcar (lambda (url-entry)
                (alist-get 'href url-entry))
              (if (vectorp urls) (append urls nil) urls)))))

(defun auth-source-op--item-matches-host-p (item host)
  "Return non-nil if ITEM has a URL matching HOST.
Uses strict hostname matching - no wildcards or subdomain inference."
  (when host
    (let ((target-host (downcase host)))
      (cl-some (lambda (url)
                 (let ((item-host (auth-source-op--extract-hostname url)))
                   (and item-host (string= item-host target-host))))
               (auth-source-op--item-urls item)))))

(defun auth-source-op--item-matches-title-p (item title)
  "Return non-nil if ITEM title matches TITLE.
Uses case-insensitive substring matching."
  (when title
    (let ((item-title (alist-get 'title item)))
      (and item-title
           (stringp item-title)
           (string-match-p (regexp-quote (downcase title))
                           (downcase item-title))))))

(defun auth-source-op--item-in-vault-p (item)
  "Return non-nil if ITEM is in one of the configured vaults.
When `auth-source-op-vaults' is nil or empty, returns t for all items.
Matches against both vault name and vault ID (case-insensitive for names)."
  (if (null auth-source-op-vaults)
      t
    (let* ((vault (alist-get 'vault item))
           (vault-id (alist-get 'id vault))
           (vault-name (alist-get 'name vault)))
      (cl-some (lambda (configured-vault)
                 (or (and vault-id (string= configured-vault vault-id))
                     (and vault-name
                          (string= (downcase configured-vault)
                                   (downcase vault-name)))))
               auth-source-op-vaults))))

(defun auth-source-op--search-items (host &optional title)
  "Search cached items matching HOST and/or TITLE.
HOST is matched against item URLs using strict hostname matching.
TITLE is matched as a case-insensitive substring of item titles.
If both HOST and TITLE are provided, items must match at least one.
Returns a list of matching items."
  (let ((items (auth-source-op--cache-get)))
    (when items
      (cl-remove-if-not
       (lambda (item)
         (or (auth-source-op--item-matches-host-p item host)
             (auth-source-op--item-matches-title-p item title)))
       items))))

;;; Item List Cache

(defvar auth-source-op--item-cache nil
  "Cached list of 1Password items.
This is a list of item summaries from `op item list --format=json'.")

(defvar auth-source-op--cache-timestamp nil
  "Timestamp when the cache was last populated.")

(defvar auth-source-op--item-timestamps nil
  "Hash table mapping item IDs to their `updated_at' timestamps.
Used to detect stale items when re-fetching.")

(defun auth-source-op--extract-item-timestamp (item)
  "Extract the `updated_at' timestamp from ITEM.
Returns the timestamp string, or nil if not present."
  (alist-get 'updated_at item))

(defun auth-source-op--build-timestamp-index (items)
  "Build a hash table mapping item IDs to their `updated_at' timestamps.
ITEMS is a list of 1Password item summaries."
  (let ((index (make-hash-table :test 'equal)))
    (dolist (item items)
      (let ((id (alist-get 'id item))
            (timestamp (auth-source-op--extract-item-timestamp item)))
        (when (and id timestamp)
          (puthash id timestamp index))))
    index))

(defun auth-source-op--item-stale-p (item)
  "Check if ITEM has been updated since it was cached.
Returns non-nil if the item's `updated_at' timestamp differs from cached.
Returns nil if item is not stale, or if no cached timestamp exists."
  (when auth-source-op--item-timestamps
    (let* ((id (alist-get 'id item))
           (current-timestamp (auth-source-op--extract-item-timestamp item))
           (cached-timestamp (gethash id auth-source-op--item-timestamps)))
      (and cached-timestamp
           current-timestamp
           (not (equal cached-timestamp current-timestamp))))))

(defun auth-source-op--detect-stale-items ()
  "Fetch current item list and return items that have changed since caching.
Returns a list of (ITEM . OLD-TIMESTAMP) for items whose `updated_at'
has changed. Returns nil if no stale items or on fetch failure."
  (let ((current-items (auth-source-op--call-op "item" "list" "--format=json")))
    (when (and current-items
               (not (eq current-items t))
               auth-source-op--item-timestamps)
      (let ((items-list (if (vectorp current-items)
                            (append current-items nil)
                          current-items))
            stale-items)
        (dolist (item items-list)
          (when (auth-source-op--item-stale-p item)
            (let* ((id (alist-get 'id item))
                   (old-timestamp (gethash id auth-source-op--item-timestamps)))
              (push (cons item old-timestamp) stale-items))))
        (nreverse stale-items)))))

(defun auth-source-op--cache-get ()
  "Return cached items, fetching from `op' if cache is empty.
This is a read-through cache - it fetches on first access."
  (unless auth-source-op--item-cache
    (auth-source-op--cache-refresh))
  auth-source-op--item-cache)

(defun auth-source-op--cache-refresh ()
  "Refresh the item cache from 1Password.
Returns the new cache contents, or nil if fetch failed.
Items are filtered by `auth-source-op-vaults' if configured.
When a single vault is configured, uses --vault flag for efficiency."
  (let* ((single-vault (and auth-source-op-vaults
                            (null (cdr auth-source-op-vaults))
                            (car auth-source-op-vaults)))
         (items (if single-vault
                    (auth-source-op--call-op "item" "list"
                                             (format "--vault=%s" single-vault)
                                             "--format=json")
                  (auth-source-op--call-op "item" "list" "--format=json"))))
    (when (and items (not (eq items t)))
      (let ((items-list (if (vectorp items) (append items nil) items)))
        (setq auth-source-op--item-cache
              (if single-vault
                  items-list
                (cl-remove-if-not #'auth-source-op--item-in-vault-p items-list)))
        (setq auth-source-op--cache-timestamp (current-time))
        (setq auth-source-op--item-timestamps
              (auth-source-op--build-timestamp-index auth-source-op--item-cache))))
    auth-source-op--item-cache))

(defun auth-source-op--cache-clear ()
  "Clear the item cache."
  (setq auth-source-op--item-cache nil)
  (setq auth-source-op--cache-timestamp nil)
  (setq auth-source-op--item-timestamps nil))

;;;###autoload
(defun auth-source-op-refresh-cache ()
  "Force refresh of the 1Password item cache."
  (interactive)
  (auth-source-op--cache-clear)
  (if (auth-source-op--cache-refresh)
      (message "auth-source-op: Cache refreshed (%d items)"
               (length auth-source-op--item-cache))
    (message "auth-source-op: Cache refresh failed")))

;;;###autoload
(defun auth-source-op-cache-clear ()
  "Clear all cached 1Password data."
  (interactive)
  (auth-source-op--cache-clear)
  (message "auth-source-op: Cache cleared"))

;;;###autoload
(defun auth-source-op-cache-list ()
  "Display cached 1Password items in a buffer.
Shows item titles and hostnames, but never displays secrets."
  (interactive)
  (let ((items (auth-source-op--cache-get)))
    (if (null items)
        (message "auth-source-op: No items in cache")
      (with-current-buffer (get-buffer-create "*1Password Cache*")
        (let ((inhibit-read-only t))
          (erase-buffer)
          (insert (format "1Password Cached Items (%d total)\n" (length items)))
          (insert (make-string 40 ?=))
          (insert "\n\n")
          (dolist (item items)
            (let* ((title (or (alist-get 'title item) "Untitled"))
                   (id (alist-get 'id item))
                   (urls (auth-source-op--item-urls item))
                   (host (auth-source-op--extract-hostname (car urls)))
                   (updated (alist-get 'updated_at item)))
              (insert (format "â€¢ %s\n" title))
              (when host
                (insert (format "  Host: %s\n" host)))
              (when id
                (insert (format "  ID: %s\n" id)))
              (when updated
                (insert (format "  Updated: %s\n" updated)))
              (insert "\n")))
          (goto-char (point-min))
          (special-mode))
        (display-buffer (current-buffer))))))

;;; op CLI Interface

(defun auth-source-op--check-op-available ()
  "Check if the `op' CLI is available.
Returns the path to `op' if found, nil otherwise.
Displays a warning if `op' is not found."
  (let ((op-path (executable-find "op")))
    (unless op-path
      (display-warning 'auth-source-op
                       "1Password CLI `op' not found in PATH. \
Install it from https://developer.1password.com/docs/cli/"
                       :warning))
    op-path))

(defun auth-source-op--call-op (&rest args)
  "Call the `op' CLI with ARGS.
Returns the parsed JSON output on success.
Retries on biometric failure up to `auth-source-op-retry-count' times.
Returns nil silently on user cancellation.
Signals an error on unexpected failures."
  (catch 'auth-source-op--return
    (unless (auth-source-op--check-op-available)
      (throw 'auth-source-op--return nil))
    (let ((retry-count 0)
          (max-retries auth-source-op-retry-count)
          result)
      (while (and (null result) (<= retry-count max-retries))
        (let* ((stderr-file (make-temp-file "op-stderr"))
               (command (mapconcat #'shell-quote-argument
                                   (cons "op" args)
                                   " "))
               (full-command (format "%s 2>%s"
                                     command
                                     (shell-quote-argument stderr-file)))
               (output (with-temp-buffer
                         (let ((exit-code (call-process-shell-command
                                           full-command nil t)))
                           (cons exit-code (buffer-string)))))
               (exit-code (car output))
               (stdout (cdr output))
               (stderr (with-temp-buffer
                         (insert-file-contents stderr-file)
                         (buffer-string))))
          (delete-file stderr-file)
          (cond
           ;; Success
           ((zerop exit-code)
            (setq result (if (string-empty-p stdout)
                             t
                           (condition-case nil
                               (json-read-from-string stdout)
                             (json-error stdout)))))
           ;; User cancelled - return nil immediately
           ((auth-source-op--user-cancelled-p stderr)
            (throw 'auth-source-op--return nil))
           ;; Biometric failure - retry
           ((auth-source-op--biometric-failure-p stderr)
            (setq retry-count (1+ retry-count))
            (when (> retry-count max-retries)
              (error "auth-source-op: Biometric authentication failed after %d attempts"
                     max-retries)))
           ;; Unexpected error
           (t
            (error "auth-source-op: `op' command failed: %s" stderr)))))
      result)))

;;; Auth-Source Backend

(cl-defun auth-source-op--search (&rest spec
                                        &key backend type host user port
                                        require max
                                        &allow-other-keys)
  "Search 1Password for credentials matching SPEC.
BACKEND is the auth-source backend object.
TYPE should be \\='1password or nil.
HOST is the hostname to match against item URLs.
USER is the username to match (used to filter results).
PORT is ignored (1Password items don't have port metadata).
REQUIRE is a list of required result keys.
MAX is the maximum number of results to return.
Returns a list of plists with :host, :user, and :secret keys."
  (ignore backend type port require)
  ;; Handle wildcard host - we don't support it
  (when (eq host t)
    (cl-return-from auth-source-op--search nil))
  (let* ((items (auth-source-op--search-items host))
         (max (or max 1))
         results)
    ;; Disambiguate if multiple items match and we only want one
    (when (and items (= max 1) (> (length items) 1))
      (setq items (list (auth-source-op--disambiguate items))))
    ;; Filter out nil (from cancelled disambiguation)
    (setq items (delq nil items))
    ;; Limit to max results
    (setq items (seq-take items max))
    ;; Fetch full details and map to auth-source format
    (dolist (item items)
      (when-let* ((result (auth-source-op--fetch-and-map-item item)))
        ;; Filter by user if specified
        (when (or (null user)
                  (eq user t)
                  (equal user (plist-get result :user)))
          (push result results))))
    (nreverse results)))

(defvar auth-source-op-backend
  (auth-source-backend
   :source "1Password"
   :type '1password
   :search-function #'auth-source-op--search)
  "Auth-source backend for 1Password.")

(defun auth-source-op--backend-parse (entry)
  "Create a 1Password auth-source backend from ENTRY.
Returns the backend when ENTRY is the symbol \\='1password, nil otherwise."
  (when (eq entry '1password)
    (auth-source-backend-parse-parameters entry auth-source-op-backend)))

;;;###autoload
(defun auth-source-op-enable ()
  "Enable 1Password as an auth-source backend.
Adds \\='1password to the front of `auth-sources'."
  (interactive)
  (unless (auth-source-op--check-op-available)
    (user-error "Cannot enable auth-source-op: `op' CLI not found"))
  (add-hook 'auth-source-backend-parser-functions #'auth-source-op--backend-parse)
  (add-to-list 'auth-sources '1password))

(provide 'auth-source-op)
;;; auth-source-op.el ends here
