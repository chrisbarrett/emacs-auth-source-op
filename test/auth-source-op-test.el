;;; auth-source-op-test.el --- Tests for auth-source-op -*- lexical-binding: t; -*-

;; Copyright (C) 2025 Chris Barrett

;; This code was generated by Claude (Anthropic) with human direction and
;; review. It is dual-licensed under The Unlicense and GPL-3.0-or-later.
;; See LICENSE for details.

;;; Commentary:

;; Tests for error handling in auth-source-op.

;;; Code:

(require 'ert)
(require 'cl-lib)

;; Add parent directory to load-path
(let ((dir (file-name-directory (or load-file-name buffer-file-name))))
  (add-to-list 'load-path (expand-file-name ".." dir)))

(require 'auth-source-op)

;;; Test Helpers

(defvar auth-source-op-test--mock-executable-find nil
  "Mock return value for `executable-find'.")

(defvar auth-source-op-test--mock-call-results nil
  "List of (exit-code stdout stderr) for successive mock calls.")

(defvar auth-source-op-test--mock-call-count 0
  "Count of mock CLI calls made.")

(defmacro auth-source-op-test--with-mocks (&rest body)
  "Execute BODY with mocked functions."
  (declare (indent 0))
  `(let ((auth-source-op-test--mock-call-count 0))
     (cl-letf (((symbol-function 'executable-find)
                (lambda (_cmd)
                  auth-source-op-test--mock-executable-find))
               ((symbol-function 'call-process-shell-command)
                (lambda (_cmd &optional _infile buffer &rest _args)
                  (let* ((result (nth auth-source-op-test--mock-call-count
                                      auth-source-op-test--mock-call-results))
                         (exit-code (nth 0 result))
                         (stdout (nth 1 result))
                         (stderr (nth 2 result)))
                    (setq auth-source-op-test--mock-call-count
                          (1+ auth-source-op-test--mock-call-count))
                    ;; Write stderr to temp file (which was created by the real code)
                    ;; Actually, we need to mock differently - let's write to a known file
                    (when (and buffer (bufferp buffer))
                      (with-current-buffer buffer
                        (insert stdout)))
                    (when buffer
                      (with-current-buffer (if (bufferp buffer) buffer
                                             (current-buffer))
                        (insert stdout)))
                    exit-code)))
               ((symbol-function 'make-temp-file)
                (lambda (_prefix &rest _args)
                  (let ((f (expand-file-name
                            (format "op-test-stderr-%d"
                                    auth-source-op-test--mock-call-count)
                            temporary-file-directory)))
                    ;; Pre-write the stderr content
                    (let* ((result (nth auth-source-op-test--mock-call-count
                                        auth-source-op-test--mock-call-results))
                           (stderr (or (nth 2 result) "")))
                      (with-temp-file f
                        (insert stderr)))
                    f))))
       ,@body)))

;;; Tests for Error Pattern Detection

(ert-deftest auth-source-op-test-biometric-failure-detection ()
  "Test detection of biometric failure patterns."
  (should (auth-source-op--biometric-failure-p "authorization denied"))
  (should (auth-source-op--biometric-failure-p "AUTHORIZATION DENIED"))
  (should (auth-source-op--biometric-failure-p "biometric authentication failed"))
  (should (auth-source-op--biometric-failure-p "Touch ID failed"))
  (should (auth-source-op--biometric-failure-p "authentication required"))
  (should-not (auth-source-op--biometric-failure-p "item not found"))
  (should-not (auth-source-op--biometric-failure-p "")))

(ert-deftest auth-source-op-test-user-cancelled-detection ()
  "Test detection of user cancellation patterns."
  (should (auth-source-op--user-cancelled-p "user cancelled"))
  (should (auth-source-op--user-cancelled-p "USER CANCELLED"))
  (should (auth-source-op--user-cancelled-p "user canceled"))
  (should (auth-source-op--user-cancelled-p "operation was aborted"))
  (should (auth-source-op--user-cancelled-p "operation was cancelled by user"))
  (should-not (auth-source-op--user-cancelled-p "authentication failed"))
  (should-not (auth-source-op--user-cancelled-p "")))

;;; Tests for op Availability Check

(ert-deftest auth-source-op-test-check-op-available-found ()
  "Test that check returns path when op is found."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op"))
    (auth-source-op-test--with-mocks
      (should (equal "/usr/local/bin/op"
                     (auth-source-op--check-op-available))))))

(ert-deftest auth-source-op-test-check-op-available-not-found ()
  "Test that check returns nil and warns when op is not found."
  (let ((auth-source-op-test--mock-executable-find nil)
        (warning-displayed nil))
    (cl-letf (((symbol-function 'display-warning)
               (lambda (&rest _args)
                 (setq warning-displayed t))))
      (auth-source-op-test--with-mocks
        (should-not (auth-source-op--check-op-available))
        (should warning-displayed)))))

;;; Tests for op CLI Calls

(ert-deftest auth-source-op-test-call-op-success ()
  "Test successful op CLI call."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"id\": \"abc123\", \"title\": \"Test\"}" ""))))
    (auth-source-op-test--with-mocks
      (let ((result (auth-source-op--call-op "item" "get" "test")))
        (should result)
        (should (equal "abc123" (alist-get 'id result)))
        (should (equal "Test" (alist-get 'title result)))))))

(ert-deftest auth-source-op-test-call-op-not-available ()
  "Test that call returns nil when op is not available."
  (let ((auth-source-op-test--mock-executable-find nil))
    (cl-letf (((symbol-function 'display-warning) #'ignore))
      (auth-source-op-test--with-mocks
        (should-not (auth-source-op--call-op "item" "list"))))))

(ert-deftest auth-source-op-test-call-op-user-cancelled ()
  "Test that user cancellation returns nil immediately without retry."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((1 "" "error: user cancelled"))))
    (auth-source-op-test--with-mocks
      (should-not (auth-source-op--call-op "item" "get" "test"))
      ;; Should only call once (no retry on cancel)
      (should (= 1 auth-source-op-test--mock-call-count)))))

(ert-deftest auth-source-op-test-call-op-biometric-retry ()
  "Test that biometric failure triggers retry."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((1 "" "error: authorization denied")
           (1 "" "error: authorization denied")
           (0 "{\"id\": \"test\"}" "")))
        (auth-source-op-retry-count 3))
    (auth-source-op-test--with-mocks
      (let ((result (auth-source-op--call-op "item" "get" "test")))
        (should result)
        (should (equal "test" (alist-get 'id result)))
        ;; Should have retried twice before succeeding
        (should (= 3 auth-source-op-test--mock-call-count))))))

(ert-deftest auth-source-op-test-call-op-biometric-exhausted ()
  "Test that exhausted biometric retries signal error."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((1 "" "error: authorization denied")
           (1 "" "error: authorization denied")
           (1 "" "error: authorization denied")
           (1 "" "error: authorization denied")))
        (auth-source-op-retry-count 3))
    (auth-source-op-test--with-mocks
      (should-error (auth-source-op--call-op "item" "get" "test")
                    :type 'error))))

(ert-deftest auth-source-op-test-call-op-unexpected-error ()
  "Test that unexpected errors signal with stderr content."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((1 "" "error: vault not found"))))
    (auth-source-op-test--with-mocks
      (should-error (auth-source-op--call-op "vault" "list")
                    :type 'error))))

(ert-deftest auth-source-op-test-call-op-empty-output ()
  "Test that empty output returns t (success with no data)."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "" ""))))
    (auth-source-op-test--with-mocks
      (should (eq t (auth-source-op--call-op "signout"))))))

;;; Tests for Item List Cache

(ert-deftest auth-source-op-test-cache-get-fetches-on-first-access ()
  "Test that cache-get fetches items on first access."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "[{\"id\": \"item1\"}, {\"id\": \"item2\"}]" "")))
        (auth-source-op--item-cache nil)
        (auth-source-op--cache-timestamp nil))
    (auth-source-op-test--with-mocks
      (let ((items (auth-source-op--cache-get)))
        (should items)
        (should (= 2 (length items)))
        (should (= 1 auth-source-op-test--mock-call-count))))))

(ert-deftest auth-source-op-test-cache-get-returns-cached-on-subsequent ()
  "Test that cache-get returns cached items without fetching again."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "[{\"id\": \"item1\"}]" "")))
        (auth-source-op--item-cache nil)
        (auth-source-op--cache-timestamp nil))
    (auth-source-op-test--with-mocks
      ;; First access fetches
      (auth-source-op--cache-get)
      (should (= 1 auth-source-op-test--mock-call-count))
      ;; Second access uses cache
      (auth-source-op--cache-get)
      (should (= 1 auth-source-op-test--mock-call-count)))))

(ert-deftest auth-source-op-test-cache-refresh-forces-fetch ()
  "Test that cache-refresh always fetches fresh data."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "[{\"id\": \"item1\"}]" "")
           (0 "[{\"id\": \"item1\"}, {\"id\": \"item2\"}]" "")))
        (auth-source-op--item-cache nil)
        (auth-source-op--cache-timestamp nil))
    (auth-source-op-test--with-mocks
      ;; First fetch
      (auth-source-op--cache-refresh)
      (should (= 1 (length auth-source-op--item-cache)))
      ;; Force refresh
      (auth-source-op--cache-refresh)
      (should (= 2 (length auth-source-op--item-cache)))
      (should (= 2 auth-source-op-test--mock-call-count)))))

(ert-deftest auth-source-op-test-cache-clear-empties-cache ()
  "Test that cache-clear empties the cache."
  (let ((auth-source-op--item-cache '(((id . "test"))))
        (auth-source-op--cache-timestamp (current-time)))
    (auth-source-op--cache-clear)
    (should-not auth-source-op--item-cache)
    (should-not auth-source-op--cache-timestamp)))

(ert-deftest auth-source-op-test-cache-sets-timestamp ()
  "Test that cache refresh sets the timestamp."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "[{\"id\": \"item1\"}]" "")))
        (auth-source-op--item-cache nil)
        (auth-source-op--cache-timestamp nil))
    (auth-source-op-test--with-mocks
      (auth-source-op--cache-refresh)
      (should auth-source-op--cache-timestamp)
      (should (time-less-p (time-subtract (current-time) 5)
                           auth-source-op--cache-timestamp)))))

(ert-deftest auth-source-op-test-cache-handles-fetch-failure ()
  "Test that cache handles fetch failure gracefully."
  (let ((auth-source-op-test--mock-executable-find nil)
        (auth-source-op--item-cache nil)
        (auth-source-op--cache-timestamp nil))
    (cl-letf (((symbol-function 'display-warning) #'ignore))
      (auth-source-op-test--with-mocks
        (should-not (auth-source-op--cache-refresh))
        (should-not auth-source-op--item-cache)))))

(ert-deftest auth-source-op-test-cache-converts-vector-to-list ()
  "Test that cache converts JSON vector to list."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "[{\"id\": \"item1\"}, {\"id\": \"item2\"}]" "")))
        (auth-source-op--item-cache nil)
        (auth-source-op--cache-timestamp nil))
    (auth-source-op-test--with-mocks
      (let ((items (auth-source-op--cache-get)))
        ;; Should be a list, not a vector
        (should (listp items))
        (should-not (vectorp items))))))

;;; Tests for Item Search

(ert-deftest auth-source-op-test-extract-hostname ()
  "Test URL hostname extraction."
  (should (equal "example.com"
                 (auth-source-op--extract-hostname "https://example.com/path")))
  (should (equal "example.com"
                 (auth-source-op--extract-hostname "http://example.com")))
  (should (equal "sub.example.com"
                 (auth-source-op--extract-hostname "https://sub.example.com/")))
  (should (equal "example.com"
                 (auth-source-op--extract-hostname "https://EXAMPLE.COM/")))
  ;; Bare hostname is valid (1Password stores URLs without protocol)
  (should (equal "example.com"
                 (auth-source-op--extract-hostname "example.com")))
  (should-not (auth-source-op--extract-hostname nil))
  (should-not (auth-source-op--extract-hostname "")))

(ert-deftest auth-source-op-test-item-urls ()
  "Test extraction of URLs from item."
  (let ((item '((urls . [((href . "https://example.com"))
                         ((href . "https://other.com"))]))))
    (should (equal '("https://example.com" "https://other.com")
                   (auth-source-op--item-urls item))))
  ;; No URLs
  (let ((item '((title . "Test"))))
    (should-not (auth-source-op--item-urls item))))

(ert-deftest auth-source-op-test-item-matches-host-strict ()
  "Test strict hostname matching - no subdomain inference."
  (let ((item '((urls . [((href . "https://example.com/login"))]))))
    ;; Exact match
    (should (auth-source-op--item-matches-host-p item "example.com"))
    ;; Case insensitive
    (should (auth-source-op--item-matches-host-p item "EXAMPLE.COM"))
    ;; Subdomain should NOT match parent
    (should-not (auth-source-op--item-matches-host-p item "sub.example.com"))
    ;; Parent should NOT match subdomain
    (should-not (auth-source-op--item-matches-host-p item "com"))))

(ert-deftest auth-source-op-test-item-matches-host-with-subdomain ()
  "Test that subdomain in item matches only that exact subdomain."
  (let ((item '((urls . [((href . "https://api.github.com"))]))))
    (should (auth-source-op--item-matches-host-p item "api.github.com"))
    (should-not (auth-source-op--item-matches-host-p item "github.com"))
    (should-not (auth-source-op--item-matches-host-p item "other.github.com"))))

(ert-deftest auth-source-op-test-item-matches-title ()
  "Test title matching."
  (let ((item '((title . "GitHub Personal Account"))))
    ;; Substring match
    (should (auth-source-op--item-matches-title-p item "GitHub"))
    ;; Case insensitive
    (should (auth-source-op--item-matches-title-p item "github"))
    (should (auth-source-op--item-matches-title-p item "PERSONAL"))
    ;; Full match
    (should (auth-source-op--item-matches-title-p item "GitHub Personal Account"))
    ;; No match
    (should-not (auth-source-op--item-matches-title-p item "GitLab"))))

(ert-deftest auth-source-op-test-search-items-by-host ()
  "Test searching items by hostname."
  (let ((auth-source-op--item-cache
         (list '((id . "1") (title . "GitHub") (urls . [((href . "https://github.com"))]))
               '((id . "2") (title . "GitLab") (urls . [((href . "https://gitlab.com"))]))
               '((id . "3") (title . "Work GitHub") (urls . [((href . "https://github.enterprise.com"))])))))
    (let ((results (auth-source-op--search-items "github.com")))
      (should (= 1 (length results)))
      (should (equal "1" (alist-get 'id (car results)))))))

(ert-deftest auth-source-op-test-search-items-by-title ()
  "Test searching items by title."
  (let ((auth-source-op--item-cache
         (list '((id . "1") (title . "GitHub Token"))
               '((id . "2") (title . "GitLab Token"))
               '((id . "3") (title . "AWS Access Key")))))
    (let ((results (auth-source-op--search-items nil "Token")))
      (should (= 2 (length results)))
      (should (member "1" (mapcar (lambda (i) (alist-get 'id i)) results)))
      (should (member "2" (mapcar (lambda (i) (alist-get 'id i)) results))))))

(ert-deftest auth-source-op-test-search-items-host-or-title ()
  "Test that search matches host OR title."
  (let ((auth-source-op--item-cache
         (list '((id . "1") (title . "GitHub") (urls . [((href . "https://github.com"))]))
               '((id . "2") (title . "My GitLab") (urls . [((href . "https://gitlab.com"))]))
               '((id . "3") (title . "GitHub Enterprise") (urls . [((href . "https://github.enterprise.com"))])))))
    ;; Match by host OR title containing "GitHub"
    (let ((results (auth-source-op--search-items "gitlab.com" "GitHub")))
      (should (= 3 (length results))))))

(ert-deftest auth-source-op-test-search-items-no-match ()
  "Test search with no matches."
  (let ((auth-source-op--item-cache
         (list '((id . "1") (title . "GitHub") (urls . [((href . "https://github.com"))])))))
    (should-not (auth-source-op--search-items "gitlab.com" "AWS"))))

(ert-deftest auth-source-op-test-search-items-empty-cache ()
  "Test search with empty cache."
  (let ((auth-source-op--item-cache nil))
    ;; Don't try to fetch in this test
    (cl-letf (((symbol-function 'auth-source-op--cache-refresh) #'ignore))
      (should-not (auth-source-op--search-items "github.com")))))

;;; Tests for Field Mapping

(ert-deftest auth-source-op-test-extract-username-from-username-field ()
  "Test extracting username from 'username' field."
  (let ((item '((fields . [((label . "username") (value . "testuser"))]))))
    (should (equal "testuser" (auth-source-op--extract-username item)))))

(ert-deftest auth-source-op-test-extract-username-from-email-field ()
  "Test extracting username from 'email' field."
  (let ((item '((fields . [((label . "email") (value . "test@example.com"))]))))
    (should (equal "test@example.com" (auth-source-op--extract-username item)))))

(ert-deftest auth-source-op-test-extract-username-case-insensitive ()
  "Test that username extraction is case-insensitive."
  (let ((item '((fields . [((label . "USERNAME") (value . "testuser"))]))))
    (should (equal "testuser" (auth-source-op--extract-username item)))))

(ert-deftest auth-source-op-test-extract-username-by-id ()
  "Test extracting username by field id."
  (let ((item '((fields . [((id . "username") (label . "User Name") (value . "testuser"))]))))
    (should (equal "testuser" (auth-source-op--extract-username item)))))

(ert-deftest auth-source-op-test-extract-username-not-found ()
  "Test that nil is returned when no username field exists."
  (let ((item '((fields . [((label . "password") (value . "secret123"))]))))
    (should-not (auth-source-op--extract-username item))))

(ert-deftest auth-source-op-test-extract-username-no-fields ()
  "Test that nil is returned when item has no fields."
  (let ((item '((title . "Test Item"))))
    (should-not (auth-source-op--extract-username item))))

(ert-deftest auth-source-op-test-find-field-value-concealed-type ()
  "Test that CONCEALED type fields are matched for password purpose."
  (let ((item '((fields . [((label . "secret key") (type . "CONCEALED") (value . "mysecret"))]))))
    (should (equal "mysecret"
                   (auth-source-op--find-field-value item '("password") 'password)))))

(ert-deftest auth-source-op-test-find-field-value-password-by-label ()
  "Test finding password by label."
  (let ((item '((fields . [((label . "password") (value . "secret123"))]))))
    (should (equal "secret123"
                   (auth-source-op--find-field-value item auth-source-op--secret-field-names 'password)))))

(ert-deftest auth-source-op-test-secret-closure-deferred ()
  "Test that secret closure defers fetching until called."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"password\", \"value\": \"secret123\"}]}" "")))
        (fetch-called nil))
    (auth-source-op-test--with-mocks
      ;; Create closure - should not call op yet
      (let ((closure (auth-source-op--make-secret-closure "test-id")))
        (should (= 0 auth-source-op-test--mock-call-count))
        ;; Call closure - should fetch now
        (let ((secret (funcall closure)))
          (should (= 1 auth-source-op-test--mock-call-count))
          (should (equal "secret123" secret)))))))

(ert-deftest auth-source-op-test-fetch-and-map-item ()
  "Test mapping a 1Password item to auth-source format."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"username\", \"value\": \"myuser\"}, {\"label\": \"password\", \"value\": \"mypass\"}]}" ""))))
    (auth-source-op-test--with-mocks
      (let* ((item '((id . "test-id")
                     (title . "Test Item")
                     (urls . [((href . "https://example.com"))])))
             (result (auth-source-op--fetch-and-map-item item)))
        (should result)
        (should (equal "example.com" (plist-get result :host)))
        (should (equal "myuser" (plist-get result :user)))
        (should (functionp (plist-get result :secret)))))))

(ert-deftest auth-source-op-test-fetch-and-map-item-uses-title-as-host ()
  "Test that title is used as host when no URLs present."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"username\", \"value\": \"myuser\"}]}" ""))))
    (auth-source-op-test--with-mocks
      (let* ((item '((id . "test-id") (title . "My Service")))
             (result (auth-source-op--fetch-and-map-item item)))
        (should (equal "My Service" (plist-get result :host)))))))

(ert-deftest auth-source-op-test-fetch-and-map-item-fetch-failure ()
  "Test that nil is returned when fetch fails."
  (let ((auth-source-op-test--mock-executable-find nil))
    (cl-letf (((symbol-function 'display-warning) #'ignore))
      (auth-source-op-test--with-mocks
        (let* ((item '((id . "test-id") (title . "Test Item")))
               (result (auth-source-op--fetch-and-map-item item)))
          (should-not result))))))

(ert-deftest auth-source-op-test-secret-closure-returns-secret ()
  "Test that calling the secret closure returns the password."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"password\", \"value\": \"supersecret\"}]}" ""))))
    (auth-source-op-test--with-mocks
      (let* ((closure (auth-source-op--make-secret-closure "item-123"))
             (secret (funcall closure)))
        (should (equal "supersecret" secret))))))

;;; Tests for Disambiguation UI

(ert-deftest auth-source-op-test-format-item-with-url ()
  "Test formatting an item with URL for display."
  (let ((item '((title . "GitHub Personal") (urls . [((href . "https://github.com/login"))]))))
    (should (equal "GitHub Personal (github.com)"
                   (auth-source-op--format-item-for-display item)))))

(ert-deftest auth-source-op-test-format-item-without-url ()
  "Test formatting an item without URL for display."
  (let ((item '((title . "API Token"))))
    (should (equal "API Token"
                   (auth-source-op--format-item-for-display item)))))

(ert-deftest auth-source-op-test-format-item-no-title ()
  "Test formatting an item without title."
  (let ((item '((id . "123"))))
    (should (equal "Untitled"
                   (auth-source-op--format-item-for-display item)))))

(ert-deftest auth-source-op-test-disambiguate-nil ()
  "Test that disambiguate returns nil for empty list."
  (should-not (auth-source-op--disambiguate nil)))

(ert-deftest auth-source-op-test-disambiguate-single-item ()
  "Test that single item is returned without prompting."
  (let ((item '((id . "1") (title . "Test")))
        (completing-read-called nil))
    (cl-letf (((symbol-function 'completing-read)
               (lambda (&rest _args)
                 (setq completing-read-called t)
                 nil)))
      (let ((result (auth-source-op--disambiguate (list item))))
        (should (equal item result))
        (should-not completing-read-called)))))

(ert-deftest auth-source-op-test-disambiguate-multiple-items ()
  "Test that completing-read is called for multiple items."
  (let ((item1 '((id . "1") (title . "GitHub")))
        (item2 '((id . "2") (title . "GitLab"))))
    (cl-letf (((symbol-function 'completing-read)
               (lambda (_prompt candidates &rest _args)
                 (car candidates))))  ; Return first candidate
      (let ((result (auth-source-op--disambiguate (list item1 item2))))
        (should (equal item1 result))))))

(ert-deftest auth-source-op-test-disambiguate-user-cancels ()
  "Test that nil is returned when user cancels selection."
  (let ((item1 '((id . "1") (title . "GitHub")))
        (item2 '((id . "2") (title . "GitLab"))))
    (cl-letf (((symbol-function 'completing-read)
               (lambda (&rest _args)
                 nil)))  ; User cancelled (keyboard-quit would throw, empty input returns nil)
      (let ((result (auth-source-op--disambiguate (list item1 item2))))
        (should-not result)))))

(ert-deftest auth-source-op-test-disambiguate-selects-correct-item ()
  "Test that the correct item is returned based on selection."
  (let ((item1 '((id . "1") (title . "First Item")))
        (item2 '((id . "2") (title . "Second Item")))
        (item3 '((id . "3") (title . "Third Item"))))
    (cl-letf (((symbol-function 'completing-read)
               (lambda (_prompt candidates &rest _args)
                 (nth 1 candidates))))  ; Select second candidate
      (let ((result (auth-source-op--disambiguate (list item1 item2 item3))))
        (should (equal item2 result))))))

;;; Tests for Auth-Source Backend

(ert-deftest auth-source-op-test-backend-parse-matches-1password ()
  "Test that backend parser matches '1password symbol."
  (should (auth-source-op--backend-parse '1password)))

(ert-deftest auth-source-op-test-backend-parse-ignores-other ()
  "Test that backend parser returns nil for other entries."
  (should-not (auth-source-op--backend-parse 'password-store))
  (should-not (auth-source-op--backend-parse "~/.authinfo"))
  (should-not (auth-source-op--backend-parse nil)))

(ert-deftest auth-source-op-test-search-returns-nil-for-wildcard-host ()
  "Test that search returns nil when host is t (wildcard)."
  (should-not (auth-source-op--search :host t)))

(ert-deftest auth-source-op-test-search-returns-nil-for-nil-host ()
  "Test that search returns nil when host is nil."
  (let ((auth-source-op--item-cache
         '(((id . "1") (title . "GitHub") (urls . [((href . "https://github.com"))])))))
    ;; With no host, search-items returns nothing (no match criteria)
    (should-not (auth-source-op--search :host nil))))

(ert-deftest auth-source-op-test-search-returns-nil-for-no-matches ()
  "Test that search returns nil when no items match."
  (let ((auth-source-op--item-cache
         '(((id . "1") (title . "GitHub") (urls . [((href . "https://github.com"))])))))
    (should-not (auth-source-op--search :host "gitlab.com"))))

(ert-deftest auth-source-op-test-search-returns-results-for-match ()
  "Test that search returns results for matching host."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"username\", \"value\": \"myuser\"}, {\"label\": \"password\", \"value\": \"mypass\"}]}" "")))
        (auth-source-op--item-cache
         '(((id . "item1") (title . "GitHub") (urls . [((href . "https://github.com"))])))))
    (auth-source-op-test--with-mocks
      (let ((results (auth-source-op--search :host "github.com")))
        (should results)
        (should (= 1 (length results)))
        (should (equal "github.com" (plist-get (car results) :host)))
        (should (equal "myuser" (plist-get (car results) :user)))
        (should (functionp (plist-get (car results) :secret)))))))

(ert-deftest auth-source-op-test-search-respects-max ()
  "Test that search respects :max parameter."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"username\", \"value\": \"user1\"}]}" "")
           (0 "{\"fields\": [{\"label\": \"username\", \"value\": \"user2\"}]}" "")))
        (auth-source-op--item-cache
         '(((id . "1") (title . "GitHub 1") (urls . [((href . "https://github.com"))]))
           ((id . "2") (title . "GitHub 2") (urls . [((href . "https://github.com"))])))))
    (auth-source-op-test--with-mocks
      (let ((results (auth-source-op--search :host "github.com" :max 2)))
        (should (= 2 (length results)))))))

(ert-deftest auth-source-op-test-search-filters-by-user ()
  "Test that search filters results by :user parameter."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"username\", \"value\": \"wronguser\"}, {\"label\": \"password\", \"value\": \"pass1\"}]}" "")
           (0 "{\"fields\": [{\"label\": \"username\", \"value\": \"rightuser\"}, {\"label\": \"password\", \"value\": \"pass2\"}]}" "")))
        (auth-source-op--item-cache
         '(((id . "1") (title . "Account 1") (urls . [((href . "https://github.com"))]))
           ((id . "2") (title . "Account 2") (urls . [((href . "https://github.com"))])))))
    (auth-source-op-test--with-mocks
      (let ((results (auth-source-op--search :host "github.com" :user "rightuser" :max 2)))
        (should (= 1 (length results)))
        (should (equal "rightuser" (plist-get (car results) :user)))))))

(ert-deftest auth-source-op-test-search-disambiguates-single-max ()
  "Test that search calls disambiguate when multiple matches and max=1."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"username\", \"value\": \"user2\"}]}" "")))
        (auth-source-op--item-cache
         '(((id . "1") (title . "GitHub Work") (urls . [((href . "https://github.com"))]))
           ((id . "2") (title . "GitHub Personal") (urls . [((href . "https://github.com"))]))))
        (disambiguate-called nil))
    (cl-letf (((symbol-function 'completing-read)
               (lambda (_prompt candidates &rest _args)
                 (setq disambiguate-called t)
                 ;; Select the second item
                 (nth 1 candidates))))
      (auth-source-op-test--with-mocks
        (let ((results (auth-source-op--search :host "github.com" :max 1)))
          (should disambiguate-called)
          (should (= 1 (length results))))))))

(ert-deftest auth-source-op-test-search-returns-nil-when-disambiguation-cancelled ()
  "Test that search returns nil when user cancels disambiguation."
  (let ((auth-source-op--item-cache
         '(((id . "1") (title . "GitHub Work") (urls . [((href . "https://github.com"))]))
           ((id . "2") (title . "GitHub Personal") (urls . [((href . "https://github.com"))])))))
    (cl-letf (((symbol-function 'completing-read)
               (lambda (&rest _args)
                 nil)))  ; User cancelled
      (should-not (auth-source-op--search :host "github.com" :max 1)))))

(ert-deftest auth-source-op-test-enable-adds-to-auth-sources ()
  "Test that enable adds 1password to auth-sources."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-sources '("~/.authinfo.gpg")))
    (auth-source-op-test--with-mocks
      (auth-source-op-enable)
      (should (memq '1password auth-sources))
      ;; Should be at the front
      (should (eq '1password (car auth-sources))))))

(ert-deftest auth-source-op-test-enable-errors-without-op ()
  "Test that enable signals error when op CLI is not found."
  (let ((auth-source-op-test--mock-executable-find nil))
    (cl-letf (((symbol-function 'display-warning) #'ignore))
      (auth-source-op-test--with-mocks
        (should-error (auth-source-op-enable)
                      :type 'user-error)))))

(ert-deftest auth-source-op-test-enable-idempotent ()
  "Test that enable is idempotent - doesn't add duplicate entries."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-sources '(1password "~/.authinfo.gpg")))
    (auth-source-op-test--with-mocks
      (auth-source-op-enable)
      ;; Should still only have one 1password entry
      (should (= 1 (cl-count '1password auth-sources))))))

;;; Tests for Cache Invalidation

(ert-deftest auth-source-op-test-extract-item-timestamp ()
  "Test extraction of updated_at timestamp from item."
  (let ((item '((id . "1") (title . "Test") (updated_at . "2025-01-15T10:30:00Z"))))
    (should (equal "2025-01-15T10:30:00Z"
                   (auth-source-op--extract-item-timestamp item))))
  ;; Missing timestamp
  (let ((item '((id . "1") (title . "Test"))))
    (should-not (auth-source-op--extract-item-timestamp item))))

(ert-deftest auth-source-op-test-build-timestamp-index ()
  "Test building timestamp index from items."
  (let* ((items '(((id . "item1") (title . "First") (updated_at . "2025-01-15T10:00:00Z"))
                  ((id . "item2") (title . "Second") (updated_at . "2025-01-15T11:00:00Z"))
                  ((id . "item3") (title . "Third"))))  ; No timestamp
         (index (auth-source-op--build-timestamp-index items)))
    (should (hash-table-p index))
    (should (equal "2025-01-15T10:00:00Z" (gethash "item1" index)))
    (should (equal "2025-01-15T11:00:00Z" (gethash "item2" index)))
    (should-not (gethash "item3" index))))  ; Missing timestamp not indexed

(ert-deftest auth-source-op-test-item-stale-p-detects-change ()
  "Test that stale detection identifies changed timestamps."
  (let ((auth-source-op--item-timestamps (make-hash-table :test 'equal)))
    (puthash "item1" "2025-01-15T10:00:00Z" auth-source-op--item-timestamps)
    ;; Same timestamp - not stale
    (let ((item '((id . "item1") (updated_at . "2025-01-15T10:00:00Z"))))
      (should-not (auth-source-op--item-stale-p item)))
    ;; Different timestamp - stale
    (let ((item '((id . "item1") (updated_at . "2025-01-15T12:00:00Z"))))
      (should (auth-source-op--item-stale-p item)))))

(ert-deftest auth-source-op-test-item-stale-p-no-cached-timestamp ()
  "Test that items without cached timestamps are not considered stale."
  (let ((auth-source-op--item-timestamps (make-hash-table :test 'equal)))
    (puthash "item1" "2025-01-15T10:00:00Z" auth-source-op--item-timestamps)
    ;; New item not in cache - not stale (it's new, not changed)
    (let ((item '((id . "item2") (updated_at . "2025-01-15T12:00:00Z"))))
      (should-not (auth-source-op--item-stale-p item)))))

(ert-deftest auth-source-op-test-item-stale-p-no-timestamp-table ()
  "Test that nil timestamp table means nothing is stale."
  (let ((auth-source-op--item-timestamps nil))
    (let ((item '((id . "item1") (updated_at . "2025-01-15T12:00:00Z"))))
      (should-not (auth-source-op--item-stale-p item)))))

(ert-deftest auth-source-op-test-cache-refresh-builds-timestamp-index ()
  "Test that cache refresh builds the timestamp index."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "[{\"id\": \"item1\", \"title\": \"Test\", \"updated_at\": \"2025-01-15T10:00:00Z\"}]" "")))
        (auth-source-op--item-cache nil)
        (auth-source-op--cache-timestamp nil)
        (auth-source-op--item-timestamps nil))
    (auth-source-op-test--with-mocks
      (auth-source-op--cache-refresh)
      (should auth-source-op--item-timestamps)
      (should (hash-table-p auth-source-op--item-timestamps))
      (should (equal "2025-01-15T10:00:00Z"
                     (gethash "item1" auth-source-op--item-timestamps))))))

(ert-deftest auth-source-op-test-cache-clear-clears-timestamps ()
  "Test that cache clear also clears timestamps."
  (let ((auth-source-op--item-cache '(((id . "test"))))
        (auth-source-op--cache-timestamp (current-time))
        (auth-source-op--item-timestamps (make-hash-table :test 'equal)))
    (puthash "test" "2025-01-15T10:00:00Z" auth-source-op--item-timestamps)
    (auth-source-op--cache-clear)
    (should-not auth-source-op--item-timestamps)))

(ert-deftest auth-source-op-test-detect-stale-items ()
  "Test detection of stale items."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "[{\"id\": \"item1\", \"updated_at\": \"2025-01-15T12:00:00Z\"}, {\"id\": \"item2\", \"updated_at\": \"2025-01-15T10:00:00Z\"}]" "")))
        (auth-source-op--item-timestamps (make-hash-table :test 'equal)))
    ;; Set up cached timestamps - item1 has old timestamp, item2 is unchanged
    (puthash "item1" "2025-01-15T10:00:00Z" auth-source-op--item-timestamps)
    (puthash "item2" "2025-01-15T10:00:00Z" auth-source-op--item-timestamps)
    (auth-source-op-test--with-mocks
      (let ((stale (auth-source-op--detect-stale-items)))
        ;; Only item1 should be stale (timestamp changed)
        (should (= 1 (length stale)))
        (should (equal "item1" (alist-get 'id (car (car stale)))))
        ;; Old timestamp should be returned
        (should (equal "2025-01-15T10:00:00Z" (cdr (car stale))))))))

(ert-deftest auth-source-op-test-detect-stale-items-empty-cache ()
  "Test that stale detection returns nil with no cached timestamps."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "[{\"id\": \"item1\", \"updated_at\": \"2025-01-15T12:00:00Z\"}]" "")))
        (auth-source-op--item-timestamps nil))
    (auth-source-op-test--with-mocks
      (should-not (auth-source-op--detect-stale-items)))))

(ert-deftest auth-source-op-test-detect-stale-items-no-changes ()
  "Test that stale detection returns nil when nothing changed."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "[{\"id\": \"item1\", \"updated_at\": \"2025-01-15T10:00:00Z\"}]" "")))
        (auth-source-op--item-timestamps (make-hash-table :test 'equal)))
    (puthash "item1" "2025-01-15T10:00:00Z" auth-source-op--item-timestamps)
    (auth-source-op-test--with-mocks
      (should-not (auth-source-op--detect-stale-items)))))

;;; Tests for Cache Management UI

(ert-deftest auth-source-op-test-cache-clear-command ()
  "Test that cache-clear command clears cache and shows message."
  (let ((auth-source-op--item-cache '(((id . "test"))))
        (auth-source-op--cache-timestamp (current-time))
        (auth-source-op--item-timestamps (make-hash-table :test 'equal))
        (message-shown nil))
    (cl-letf (((symbol-function 'message)
               (lambda (fmt &rest _args)
                 (when (string-match-p "cleared" fmt)
                   (setq message-shown t)))))
      (auth-source-op-cache-clear)
      (should-not auth-source-op--item-cache)
      (should-not auth-source-op--cache-timestamp)
      (should-not auth-source-op--item-timestamps)
      (should message-shown))))

(ert-deftest auth-source-op-test-cache-list-empty ()
  "Test that cache-list shows message when cache is empty."
  (let ((auth-source-op--item-cache nil)
        (message-shown nil))
    (cl-letf (((symbol-function 'auth-source-op--cache-refresh) #'ignore)
              ((symbol-function 'message)
               (lambda (fmt &rest _args)
                 (when (string-match-p "No items" fmt)
                   (setq message-shown t)))))
      (auth-source-op-cache-list)
      (should message-shown))))

(ert-deftest auth-source-op-test-cache-list-creates-buffer ()
  "Test that cache-list creates buffer with item info."
  (let ((auth-source-op--item-cache
         '(((id . "item1")
            (title . "GitHub")
            (urls . [((href . "https://github.com"))])
            (updated_at . "2025-01-15T10:00:00Z"))
           ((id . "item2")
            (title . "GitLab"))))
        (buffer-displayed nil))
    (cl-letf (((symbol-function 'display-buffer)
               (lambda (buf)
                 (setq buffer-displayed t)
                 buf)))
      (auth-source-op-cache-list)
      (should buffer-displayed)
      (with-current-buffer "*1Password Cache*"
        (let ((content (buffer-string)))
          ;; Check header
          (should (string-match-p "1Password Cached Items (2 total)" content))
          ;; Check first item
          (should (string-match-p "• GitHub" content))
          (should (string-match-p "Host: github.com" content))
          (should (string-match-p "ID: item1" content))
          (should (string-match-p "Updated: 2025-01-15T10:00:00Z" content))
          ;; Check second item (no URL)
          (should (string-match-p "• GitLab" content))
          (should (string-match-p "ID: item2" content))
          ;; Secrets should never appear (check for actual password values,
          ;; not "1Password" in the title)
          (should-not (string-match-p "password:" content))
          (should-not (string-match-p "secret:" content))))
      ;; Clean up
      (kill-buffer "*1Password Cache*"))))

(ert-deftest auth-source-op-test-cache-list-special-mode ()
  "Test that cache-list buffer uses special-mode (read-only)."
  (let ((auth-source-op--item-cache
         '(((id . "item1") (title . "Test")))))
    (cl-letf (((symbol-function 'display-buffer) #'ignore))
      (auth-source-op-cache-list)
      (with-current-buffer "*1Password Cache*"
        (should (derived-mode-p 'special-mode))
        (should buffer-read-only))
      (kill-buffer "*1Password Cache*"))))

(ert-deftest auth-source-op-test-cache-list-untitled-item ()
  "Test that cache-list handles items without titles."
  (let ((auth-source-op--item-cache
         '(((id . "item1")))))  ; No title
    (cl-letf (((symbol-function 'display-buffer) #'ignore))
      (auth-source-op-cache-list)
      (with-current-buffer "*1Password Cache*"
        (should (string-match-p "• Untitled" (buffer-string))))
      (kill-buffer "*1Password Cache*"))))

;;; Tests for Secret TTL Caching

(ert-deftest auth-source-op-test-secret-closure-caches-secret ()
  "Test that secret closure caches the secret after first fetch."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"password\", \"value\": \"secret123\"}]}" "")))
        (auth-source-op--secret-closures nil)
        (auth-source-op-secret-ttl 180))
    (auth-source-op-test--with-mocks
      (let ((closure (auth-source-op--make-secret-closure "test-id")))
        ;; First call fetches from op
        (should (equal "secret123" (funcall closure)))
        (should (= 1 auth-source-op-test--mock-call-count))
        ;; Second call uses cached value (no additional fetch)
        (should (equal "secret123" (funcall closure)))
        (should (= 1 auth-source-op-test--mock-call-count))))))

(ert-deftest auth-source-op-test-secret-closure-deduplication ()
  "Test that same item-id returns same closure (eq)."
  (let ((auth-source-op--secret-closures nil))
    (let ((closure1 (auth-source-op--make-secret-closure "item-123"))
          (closure2 (auth-source-op--make-secret-closure "item-123")))
      (should (eq closure1 closure2)))))

(ert-deftest auth-source-op-test-secret-closure-different-items ()
  "Test that different item-ids get different closures."
  (let ((auth-source-op--secret-closures nil))
    (let ((closure1 (auth-source-op--make-secret-closure "item-1"))
          (closure2 (auth-source-op--make-secret-closure "item-2")))
      (should-not (eq closure1 closure2)))))

(ert-deftest auth-source-op-test-cache-clear-clears-secret-closures ()
  "Test that cache-clear also clears the secret closure registry."
  (let ((auth-source-op--item-cache '(((id . "test"))))
        (auth-source-op--cache-timestamp (current-time))
        (auth-source-op--item-timestamps (make-hash-table :test 'equal))
        (auth-source-op--secret-closures (make-hash-table :test 'equal)))
    (puthash "item1" (lambda () "test") auth-source-op--secret-closures)
    (auth-source-op--cache-clear)
    (should-not auth-source-op--secret-closures)))

(ert-deftest auth-source-op-test-secret-ttl-expiry ()
  "Test that secret is cleared from memory after TTL expires."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"password\", \"value\": \"secret123\"}]}" "")
           (0 "{\"fields\": [{\"label\": \"password\", \"value\": \"secret456\"}]}" "")))
        (auth-source-op--secret-closures nil)
        (auth-source-op-secret-ttl 0.1))  ; 100ms TTL for testing
    (auth-source-op-test--with-mocks
      (let ((closure (auth-source-op--make-secret-closure "test-id")))
        ;; First call fetches and caches
        (should (equal "secret123" (funcall closure)))
        (should (= 1 auth-source-op-test--mock-call-count))
        ;; Wait for TTL to expire
        (sleep-for 0.2)
        ;; Next call should fetch again (secret was cleared)
        (should (equal "secret456" (funcall closure)))
        (should (= 2 auth-source-op-test--mock-call-count))))))

(ert-deftest auth-source-op-test-secret-ttl-sliding-window ()
  "Test that accessing secret resets the TTL timer."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"password\", \"value\": \"secret123\"}]}" "")))
        (auth-source-op--secret-closures nil)
        (auth-source-op-secret-ttl 0.2))  ; 200ms TTL
    (auth-source-op-test--with-mocks
      (let ((closure (auth-source-op--make-secret-closure "test-id")))
        ;; First call
        (funcall closure)
        (should (= 1 auth-source-op-test--mock-call-count))
        ;; Wait 100ms (half the TTL)
        (sleep-for 0.1)
        ;; Access again - should reset timer
        (funcall closure)
        (should (= 1 auth-source-op-test--mock-call-count))
        ;; Wait another 100ms (past original expiry, but timer was reset)
        (sleep-for 0.1)
        ;; Should still use cached value
        (funcall closure)
        (should (= 1 auth-source-op-test--mock-call-count))))))

(ert-deftest auth-source-op-test-secret-closure-registry-initialized ()
  "Test that closure registry is initialized on first use."
  (let ((auth-source-op--secret-closures nil))
    (auth-source-op--make-secret-closure "test-id")
    (should auth-source-op--secret-closures)
    (should (hash-table-p auth-source-op--secret-closures))))

(ert-deftest auth-source-op-test-secret-not-in-registry ()
  "Test that secrets cannot be accessed by inspecting the registry."
  (let ((auth-source-op-test--mock-executable-find "/usr/local/bin/op")
        (auth-source-op-test--mock-call-results
         '((0 "{\"fields\": [{\"label\": \"password\", \"value\": \"topsecret\"}]}" "")))
        (auth-source-op--secret-closures nil))
    (auth-source-op-test--with-mocks
      (let ((closure (auth-source-op--make-secret-closure "item-123")))
        ;; Fetch the secret (so it's cached in the closure)
        (funcall closure)
        ;; The registry contains the closure, but the secret is in a lexical binding
        ;; We can't directly access the secret without calling the closure
        (let ((stored-closure (gethash "item-123" auth-source-op--secret-closures)))
          (should (eq closure stored-closure))
          ;; The closure is opaque - we can only get the secret by calling it
          (should (functionp stored-closure)))))))

(provide 'auth-source-op-test)
;;; auth-source-op-test.el ends here
